import numpy as np
from smooth.adam_general._adam_general import adam_fitter


def sma(y, order=1, h=10, holdout=False):
    """SMA"""
    y = y.astype(np.float64)

    ic = lambda e: np.sum(e**2)
    obs_all = len(y) + h * (1 - holdout)
    obs_in_sample = len(y) - h * holdout
    y_in_sample = y

    E_type = "A"
    T_type = "N"
    S_type = "N"

    components_num_ETS = 0
    components_num_ETS_seasonal = 0
    xreg_number = 0
    constant_required = False
    ot = np.ones_like(y_in_sample)

    def creator_sma(order):
        # lags_model_all = np.ones(shape=(order, 1))
        # This needs to be a vector of values
        lags_model_all = np.arange(1, order + 1).reshape(order, 1)
        lags_model_max = max(lags_model_all)
        obs_states = obs_in_sample + lags_model_max

        # profiles_recent_table = np.zeros(
        #     shape=(order, lags_model_max), dtype=np.float64
        # )

        # This needs to be generated by a profileCreator() function
        profiles_recent_table = np.mean(y_in_sample[0 : (order - 1)]) * np.ones(
            shape=(order, lags_model_max), dtype=np.float64
        )

        # This as well...
        index_lookup_table = np.tile(np.arange(order), (obs_all + lags_model_max, 1)).T

        matF = np.ones((order, order)) / order
        matWt = np.ones((obs_in_sample, order))

        vecG = np.ones(order) / order
        # matVt = np.zeros((order, obs_states))
        matVt = np.empty((order, obs_states))
        # matVt.fill(np.nan)

        adam_fitted = adam_fitter(
            matrixVt=matVt,
            matrixWt=matWt,
            matrixF=matF,
            vectorG=vecG,
            lags=lags_model_all,
            indexLookupTable=index_lookup_table,
            profilesRecent=profiles_recent_table,
            E=E_type,
            T=T_type,
            S=S_type,
            nNonSeasonal=components_num_ETS,
            nSeasonal=components_num_ETS_seasonal,
            nArima=order,
            nXreg=xreg_number,
            constant=constant_required,
            vectorYt=y_in_sample,
            vectorOt=ot,
            backcast=True,
        )

        return adam_fitted

    return creator_sma(order=order)


def adamProfileCreator(
    lagsModelAll, lagsModelMax, obsAll, lags=None, yIndex=None, yClasses=None
):
    """
    Creates recent profile and the lookup table for adam.

    Parameters:
    lagsModelAll (list): All lags used in the model for ETS + ARIMA + xreg.
    lagsModelMax (int): The maximum lag used in the model.
    obsAll (int): Number of observations to create.
    lags (list): The original lags provided by user (optional).
    yIndex (list): The indices needed to get the specific dates (optional).
    yClasses (list): The class used for the actual data (optional).

    Returns:
    dict: A dictionary with 'recent' (profilesRecentTable) and 'lookup' (indexLookupTable) as keys.
    """
    # Initialize matrices
    profilesRecentTable = np.zeros((len(lagsModelAll), lagsModelMax))
    indexLookupTable = np.ones((len(lagsModelAll), obsAll + lagsModelMax))
    profileIndices = (
        np.arange(1, lagsModelMax * len(lagsModelAll) + 1)
        .reshape(-1, len(lagsModelAll))
        .T
    )

    # Update matrices based on lagsModelAll
    for i, lag in enumerate(lagsModelAll):
        # Create the matrix with profiles based on the provided lags.
        # For every row, fill the first 'lag' elements from 1 to lag
        profilesRecentTable[i, :lag] = np.arange(1, lag + 1)

        # For the i-th row in indexLookupTable, fill with a repeated sequence starting from lagsModelMax to the end of the row.
        # The repeated sequence is the i-th row of profileIndices, repeated enough times to cover 'obsAll' observations.
        # '- 1' at the end adjusts these values to Python's zero-based indexing.
        indexLookupTable[i, lagsModelMax : (lagsModelMax + obsAll)] = (  # noqa
            np.tile(
                profileIndices[i, : lagsModelAll[i]],
                int(np.ceil(obsAll / lagsModelAll[i])),
            )[0:obsAll]
            - 1
        )

        # Extract unique values from from lagsModelMax to lagsModelMax + obsAll of indexLookupTable
        unique_values = np.unique(
            indexLookupTable[i, lagsModelMax : lagsModelMax + obsAll]  # noqa
        )

        # fix the head of teh data before the sample starts
        # Repeat the unique values lagsModelMax times and then trim the sequence to only keep the first lagsModelMax elements
        indexLookupTable[i, :lagsModelMax] = np.tile(unique_values, lagsModelMax)[
            -lagsModelMax:
        ]

    # Convert to int!
    indexLookupTable = indexLookupTable.astype(int)

    # Note: I skip andling of special cases (e.g., daylight saving time, leap years)
    return {"recent": profilesRecentTable, "lookup": indexLookupTable}
